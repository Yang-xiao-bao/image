import { asyncConvolve } from "./asyncConvolve";
import { Control } from './runner'
import * as math from 'mathjs'

export function* convolve(
  img: ImageData,
  kernel: number[][],
) {
  const splited = trySplit(kernel)
  if (splited && isSeparable(kernel, splited)) {
    let it = floatConvolve(img, splited.rowKernel);//splited.rowKernel[0].map(i => [i]))
    let progress = 0
    let r = it.next(yield progress)
    console.log(splited)

    while (true) {
      if (r.done) {
        break
      } else {
        progress = r.value
      }
      r = it.next(yield progress * 0.5)
    }
    it = floatConvolve(r.value!, splited.colKernel);
    r = it.next(yield 0.5)
    while (true) {
      if (r.done) {
        break
      } else {
        progress = r.value
      }
      r = it.next(yield (progress * 0.5) + 0.5)
    }

    return new ImageData(
      new Uint8ClampedArray(r.value!.data),
      img.width,
      img.height,
    )
  }
  return yield* asyncConvolve(img, kernel)
}


type FloatImageData = {
  width: number, height: number, data: Float32Array
}
export function* floatConvolve(
  img: FloatImageData | ImageData,
  kernel: number[][]) {

  let counter = 0
  const result: FloatImageData = {
    width: img.width,
    height: img.height,
    data: new Float32Array(img.width * img.height * 4)
  }
  const kernelWidth = kernel[0].length;
  const kernelHeight = kernel.length;
  const size = img.width * img.height //(img.width + (kernelWidth-1)) * (img.height + (kernelHeight-1))
  const STEP = ~~(size * 0.01)
  const cx = Math.floor(kernelWidth / 2);
  const cy = Math.floor(kernelHeight / 2);

  // center
  //let maxX = img.width-1 - Math.ceil(kernelWidth/2)+1
  let centerMaxX = img.width - Math.ceil(kernelWidth / 2)
  let centerMaxY = img.height - Math.ceil(kernelHeight / 2)
  for (let x = cx; x <= centerMaxX; x++) {
    for (let y = cy; y <= centerMaxY; y++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let kx = 0; kx < kernelWidth; kx++) {
        for (let ky = 0; ky < kernelHeight; ky++) {
          // cx,cy 与 x y 对齐
          const px = x + kx - cx
          const py = y + ky - cy
          const ind = (py * img.width + px) * 4
          const k = kernel[kernelHeight - ky - 1][kernelWidth - kx - 1]
          r += img.data[ind + 0] * k
          g += img.data[ind + 1] * k
          b += img.data[ind + 2] * k
        }
      }
      const ind = (y * img.width + x) * 4
      result.data[ind + 0] = r;
      result.data[ind + 1] = g;
      result.data[ind + 2] = b;
      result.data[ind + 3] = 255;
      if (++counter % STEP === 0) {
        const control: Control = yield (counter / size)
        if (control === 'halt') return
      }
    }
  }
  //top
  for (let x = 0; x < img.width; x++) {
    for (let y = 0; y < cy; y++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let kx = 0; kx < kernelWidth; kx++) {
        for (let ky = 0; ky < kernelHeight; ky++) {
          // cx,cy 与 x y 对齐
          const px = x + kx - cx
          const py = y + ky - cy
          const ind = (py * img.width + px) * 4
          const k = kernel[kernelHeight - ky - 1][kernelWidth - kx - 1]
          if (px < 0 || px >= img.width || py < 0 || py >= img.height) {
            continue
          }
          r += img.data[ind + 0] * k
          g += img.data[ind + 1] * k
          b += img.data[ind + 2] * k
        }
      }
      const ind = (y * img.width + x) * 4
      result.data[ind + 0] = r;
      result.data[ind + 1] = g;
      result.data[ind + 2] = b;
      result.data[ind + 3] = 255;
      if (++counter % STEP === 0) {
        const control: Control = yield (counter / size)
        if (control === 'halt') return
      }
    }
  }
  // bottom
  let yStart = img.height - (Math.ceil(kernelHeight / 2) - 1)
  for (let x = 0; x < img.width; x++) {
    for (let y = yStart; y < img.height; y++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let kx = 0; kx < kernelWidth; kx++) {
        for (let ky = 0; ky < kernelHeight; ky++) {
          // cx,cy 与 x y 对齐
          const px = x + kx - cx
          const py = y + ky - cy
          const ind = (py * img.width + px) * 4
          const k = kernel[kernelHeight - ky - 1][kernelWidth - kx - 1]
          if (px < 0 || px >= img.width || py < 0 || py >= img.height) {
            continue
          }
          r += img.data[ind + 0] * k
          g += img.data[ind + 1] * k
          b += img.data[ind + 2] * k
        }
      }
      const ind = (y * img.width + x) * 4
      result.data[ind + 0] = r;
      result.data[ind + 1] = g;
      result.data[ind + 2] = b;
      result.data[ind + 3] = 255;
      if (++counter % STEP === 0) {
        const control: Control = yield (counter / size)
        if (control === 'halt') return
      }
    }
  }
  // left
  for (let x = 0; x < cx; x++) {
    for (let y = cy; y < yStart; y++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let kx = 0; kx < kernelWidth; kx++) {
        for (let ky = 0; ky < kernelHeight; ky++) {
          // cx,cy 与 x y 对齐
          const px = x + kx - cx
          const py = y + ky - cy
          const ind = (py * img.width + px) * 4
          const k = kernel[kernelHeight - ky - 1][kernelWidth - kx - 1]
          if (px < 0) {
            continue
          }
          r += img.data[ind + 0] * k
          g += img.data[ind + 1] * k
          b += img.data[ind + 2] * k
        }
      }
      const ind = (y * img.width + x) * 4
      result.data[ind + 0] = r;
      result.data[ind + 1] = g;
      result.data[ind + 2] = b;
      result.data[ind + 3] = 255;
      if (++counter % STEP === 0) {
        const control: Control = yield (counter / size)
        if (control === 'halt') return
      }

    }
  }
  // right
  for (let x = centerMaxX + 1; x < img.width; x++) {
    for (let y = cy; y < yStart; y++) {
      let r = 0;
      let g = 0;
      let b = 0;

      for (let kx = 0; kx < kernelWidth; kx++) {
        for (let ky = 0; ky < kernelHeight; ky++) {
          // cx,cy 与 x y 对齐
          const px = x + kx - cx
          const py = y + ky - cy
          const ind = (py * img.width + px) * 4
          const k = kernel[kernelHeight - ky - 1][kernelWidth - kx - 1]
          if (px >= img.width) {
            continue
          }
          r += img.data[ind + 0] * k
          g += img.data[ind + 1] * k
          b += img.data[ind + 2] * k
        }
      }
      const ind = (y * img.width + x) * 4
      result.data[ind + 0] = r;
      result.data[ind + 1] = g;
      result.data[ind + 2] = b;
      result.data[ind + 3] = 255;
      if (++counter % STEP === 0) {
        const control: Control = yield (counter / size)
        if (control === 'halt') return
      }
    }
  }
  yield 1
  return result
}


function isSeparable(kernel: number[][],
  splited: { rowKernel: number[][], colKernel: number[][] }
) {
  const k1 = math.matrix(kernel)
  const k2 = math.multiply(
    math.matrix(splited.colKernel),
    math.matrix(splited.rowKernel)
  )

  const m = math.equal(
    k1,
    k2
  ) as math.Matrix
  return ((m.toArray() as any) as boolean[][]).flat().every(i => i)
}

function trySplit(kernel: number[][]) {
  let rowIdx = 0;
  let colIdx = 0;
  let width = kernel[0].length;
  let height = kernel.length;
  let nonZero = false;
  outer:
  while (colIdx < height) {
    rowIdx = 0
    while (rowIdx < width) {
      rowIdx++;
      if (kernel[colIdx][rowIdx] !== 0) {
        nonZero = true
        break outer;
      }
    }
    colIdx++
  }
  if (nonZero) {
    const colKernel: number[][] = []
    for (const rowVector of kernel) {
      colKernel.push([rowVector[colIdx]])
    }
    return {
      rowKernel: [kernel[rowIdx].map(i => i / kernel[rowIdx][colIdx])] as number[][],
      colKernel
    }
  }
  return null
}
